#k8s #argocd #kustomize #deployment #medium 

![](https://miro.medium.com/v2/resize:fit:1050/1*SLR5xoixvCLrgychvrkVEg.png)

## Introduction

YouTube Tutorial:Â [https://youtu.be/VgkQQpfanck](https://youtu.be/bx-Q_m7b1MI)

Welcome! In this guide, weâ€™ll explore how to combine two powerful Kubernetes tools â€” Kustomize and Helm â€” to manage your applications across multiple environments using GitOps principles with Argo CD.

If youâ€™ve ever struggled with managing different configurations for dev, staging, and production environments, or found yourself copying and pasting Helm values files everywhere, this guide is for you.

Weâ€™ll use PostgreSQL as our example application, but the patterns youâ€™ll learn apply to any Helm chart you want to deploy. By the end of this article, youâ€™ll understand:

- Why combining Kustomize and Helm makes sense
- How to structure your Git repository for multi-environment deployments
- How to configure Argo CD to work with Kustomize and Helm
- How to securely manage secrets using SealedSecrets

Letâ€™s dive in!

## The Challenge: Managing Multi-Environment Helm Deployments

## The Traditional Approach (And Its Problems)

When deploying Helm charts with Argo CD, the typical approach is to embed your values directly in the Argo CD Application manifest or use inline overrides. While this works for simple, single-environment setups, it quickly becomes painful as you scale:

**Problems youâ€™ll face:**

- ğŸ”´Â **Tight coupling**: Your configuration values are embedded in the Argo CD Application definition
- ğŸ”´Â **Poor reusability**: Hard to use the same Helm chart across dev, staging, and prod
- ğŸ”´Â **Version control mess**: Different values files scattered across multiple Application manifests
- ğŸ”´Â **Difficult to review**: Changes to values are mixed with application configuration
- ğŸ”´Â **No clear promotion path**: How do you promote changes from dev to staging to prod?

## The Better Way: Kustomize + Helm

By introducing Kustomize as a layer between Argo CD and Helm, you gain:

- âœ…Â **Clean separation**: Each environment gets its own directory with its ownÂ `values.yaml`
- âœ…Â **Reusability**: Use the same Helm chart, just point to different value files
- âœ…Â **GitOps-friendly**: All configuration lives in Git with clear directory structure
- âœ…Â **Easy promotion**: Copy or merge changes between environment directories
- âœ…Â **Better reviews**: Git diffs clearly show what changed per environment

Think of Kustomize as theÂ **organizer**Â for your Helm charts, allowing you to maintain environment-specific configurations in a structured, maintainable way.

## Important Things to Know Before We Start

Before we jump into the implementation, there are two important concepts you need to understand about how Kustomize and Helm work together.

## Values Files: One File Per Environment (Not Merged)

**Important:**Â Unlike the Helm CLI which lets you merge multiple values files (`helm install --values base.yaml --values dev.yaml`), Kustomizeâ€™sÂ `valuesFile`Â propertyÂ **does NOT support merging**.

This means each environmentâ€™s values file must containÂ **all**Â the values you want to customize â€” both common settings and environment-specific settings.

**You have two options:**

**Option 1: Complete Values Per Environment (Recommended)**

Keep all values in each environmentâ€™s file:

# dev/values-dev.yaml  
image:  
  repository: bitnamilegacy/postgresql  
  tag: 17.6.0-debian-12-r4

auth:  
  username: "dev"  
  database: "postgres"  
  existingSecret: postgresql-credentialsresources:  
  requests:  
    cpu: 100m  
    memory: 512Mi

**Why we recommend this:**

- âœ… Simpler and more explicit â€” everything is in one place
- âœ… Easier to troubleshoot â€” you see the complete picture
- âœ… Standard Helm pattern â€” matches how most teams work
- âœ… GitOps friendly â€” clear diffs when values change

**Option 2: Use**Â `valuesInline`Â **for Overrides (Not Recommended)**

You can combineÂ `valuesFile`Â withÂ `valuesInline`:

helmCharts:  
  - name: postgresql  
    valuesFile: ../base/values.yaml  # Common values  
    valuesInline:                     # Environment overrides  
      auth:  
        username: "dev"

**Why we donâ€™t recommend this:**

- âŒ Gets messy with complex configurations
- âŒ YAML formatting issues with multiline strings
- âŒ Harder to validate â€” canâ€™t test withÂ `helm template`
- âŒ Less familiar to most engineers

**Our recommendation:**Â Embrace some duplication. Keep complete values files per environment. Itâ€™s clearer and easier to maintain.

## Overlays: Why We Donâ€™t Use a â€œBaseâ€ for Helm Charts

You might be wondering:Â _â€œWhy not put the Helm chart in the_Â `base/`Â _directory?"_

Good question! For simple Helm charts like PostgreSQL that donâ€™t have shared Kubernetes resources (besides secrets), we donâ€™t need a base at all. Each environment directly references the Helm chart with its own values.

**Our directory structure:**

postgresql-gitops/  
â”œâ”€â”€ argocd/              # Argo CD Application manifests  
â”œâ”€â”€ base/                # Empty (no shared resources for this use case)  
â”œâ”€â”€ dev/                 # Dev environment  
â”‚   â”œâ”€â”€ kustomization.yaml  
â”‚   â”œâ”€â”€ values-dev.yaml  
â”‚   â””â”€â”€ postgresql-credentials-secret.yaml  
â”œâ”€â”€ staging/             # Staging environment  
â”‚   â”œâ”€â”€ kustomization.yaml  
â”‚   â”œâ”€â”€ values-staging.yaml  
â”‚   â””â”€â”€ postgresql-credentials-secret.yaml  
â””â”€â”€ prod/                # Production environment  
    â”œâ”€â”€ kustomization.yaml  
    â”œâ”€â”€ values-prod.yaml  
    â””â”€â”€ postgresql-credentials-secret.yaml

**Key insight:**Â TheÂ `base/`Â directory is optional. Use it only when you have shared Kubernetes resources. For Helm charts where everything is environment-specific, you can skip it entirely.

## Getting Started: Installing Kustomize

First, letâ€™s make sure you have Kustomize installed. Youâ€™ll need version 4.1.0 or later to use Helm chart inflation.

# Install Kustomize  
curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash  
sudo mv kustomize /usr/local/bin

# Verify installation  
kustomize version  
# Output: v5.8.0 (or later)

Great! Now youâ€™re ready to proceed.

## Understanding the Directory Structure

Letâ€™s take a closer look at how we organize our PostgreSQL deployment:

$ tree postgresql-gitops

postgresql-gitops/  
â”œâ”€â”€ argocd/                                    # Argo CD configurations  
â”‚   â”œâ”€â”€ postgresql-applicationset.yaml        # Multi-environment manager  
â”‚   â”œâ”€â”€ postgresql-dev-application.yaml       # Dev application  
â”‚   â”œâ”€â”€ postgresql-prod-application.yaml      # Prod application  
â”‚   â””â”€â”€ postgresql-staging-application.yaml   # Staging application  
â”œâ”€â”€ base/  
â”‚   â””â”€â”€ kustomization.yaml                    # Empty base (not used here)  
â”œâ”€â”€ dev/                                       # Development environment  
â”‚   â”œâ”€â”€ kustomization.yaml                    # Dev Kustomize config  
â”‚   â”œâ”€â”€ postgresql-credentials-secret.yaml    # Dev secrets (sealed)  
â”‚   â””â”€â”€ values-dev.yaml                       # Dev Helm values  
â”œâ”€â”€ prod/                                      # Production environment  
â”‚   â”œâ”€â”€ kustomization.yaml  
â”‚   â”œâ”€â”€ postgresql-credentials-secret.yaml  
â”‚   â””â”€â”€ values-prod.yaml  
â””â”€â”€ staging/                                   # Staging environment  
    â”œâ”€â”€ kustomization.yaml  
    â”œâ”€â”€ postgresql-credentials-secret.yaml  
    â””â”€â”€ values-staging.yaml

**What each directory does:**

- `argocd/`: Contains Argo CD Application manifests that tell Argo CD what to deploy and where
- `base/`: Typically holds shared resources (empty in our case)
- `dev/`**,**Â `staging/`**,**Â `prod/`: Each environment directory contains:
- `kustomization.yaml`Â - Tells Kustomize what to include and how to build
- `values-*.yaml`Â - Helm values specific to this environment
- `postgresql-credentials-secret.yaml`Â - Encrypted secrets for this environment

This structure gives you a clear separation between environments while keeping everything in version control.

## The Dev Environment: A Detailed Walkthrough

Letâ€™s examine the development environment configuration in detail.

## dev/kustomization.yaml: The Kustomize Configuration

This file tells Kustomize how to assemble everything for the dev environment:

dev/kustomization.yaml

apiVersion: kustomize.config.k8s.io/v1beta1  
kind: Kustomization

namespace: dev  resources:    
  - postgresql-credentials-secret.yamlhelmCharts:    
  - name: postgresql  
    repo: [https://charts.bitnami.com/bitnami](https://charts.bitnami.com/bitnami)  
    version: 16.7.27    
    releaseName: postgresql  
    namespace: dev  
    valuesFile: values-dev.yaml

1. All resources will be deployed to theÂ `dev`Â namespace
2. Additional Kubernetes resources to include (secrets in this case)
3. Helm charts to inflate and include
4. Pin the chart version for reproducibility
5. Use dev-specific Helm values

**What happens when you build this:**

1. Kustomize fetches the PostgreSQL Helm chart from Bitnami
2. It renders the chart usingÂ `values-dev.yaml`
3. It combines the rendered manifests with the sealed secret
4. It sets the namespace toÂ `dev`Â for all resources
5. It outputs complete, ready-to-deploy Kubernetes manifests

## dev/values-dev.yaml: The Helm Values

This file customizes the PostgreSQL Helm chart for the development environment:

dev/values-dev.yaml

# Container image configuration  
image:  
  registry: docker.io  
  repository: bitnamilegacy/postgresql  
  tag: 17.6.0-debian-12-r4

# Authentication  
auth:  
  username: "dev"    
  database: "postgres"  
  existingSecret: postgresql-credentials  # PostgreSQL primary instance configuration  
primary:  # pg_hba.conf - Client authentication configuration  
  pgHbaConfiguration: |-    
    local   all             all                                     trust  
    host    all             all             127.0.0.1/32            trust  
    host    all             all             ::1/128                 trust  
    local   replication     all                                     trust  
    host    replication     all             127.0.0.1/32            trust  
    host    replication     all             ::1/128                 trust  
    host    all             all             10.0.0.0/8              trust  
    host    all             all             192.168.0.0/16          trust  # PostgreSQL advanced configuration  
  extendedConfiguration: |-    
    wal_level = logical  
    max_replication_slots = 10  
    max_wal_senders = 10  
    max_connections = 200  # Resource limits (smaller for dev)  
  resources:    
    requests:  
      cpu: 100m  
      memory: 512Mi  
    limits:  
      cpu: 500m  
      memory: 1024Mi  # Database initialization scripts  
  initdb:    
    scripts:  
      create-databases.sql: |  
        CREATE DATABASE service_foundry;  
        GRANT ALL PRIVILEGES ON DATABASE service_foundry TO dev;        CREATE DATABASE keycloak;  
        GRANT ALL PRIVILEGES ON DATABASE keycloak TO dev;

1. Development-specific username
2. Reference to the sealed secret weâ€™ll create
3. PostgreSQL client authentication rules (permissive for dev)
4. Advanced PostgreSQL settings (configured for logical replication)
5. Lower resource requests for dev (weâ€™ll increase these in production)
6. SQL scripts to run on first startup

**Compare this to production:**Â YourÂ `prod/values-prod.yaml`Â would have: * Higher resource limits * Stricter authentication rules * Production username * Possibly different PostgreSQL settings

## Testing Locally with Kustomize

Before we set up Argo CD, letâ€™s test that our Kustomize configuration works:

# Navigate to your project directory  
cd postgresql-gitops

# Build and preview the manifests  
kustomize build dev --enable-helm# To actually deploy to your cluster  
kustomize build dev --enable-helm | kubectl apply -f -

## About theÂ `--enable-helm`Â Flag

**Why is this flag required?**

Kustomize doesnâ€™t natively support Helm charts. When you include aÂ `helmCharts:`Â section in yourÂ `kustomization.yaml`, you must useÂ `--enable-helm`Â to tell Kustomize:

1. â€œHey, I have Helm charts in hereâ€
2. â€œPlease download these charts from the specified repoâ€
3. â€œRender them using the values file I specifiedâ€
4. â€œInclude the rendered manifests in the final outputâ€

Without this flag, Kustomize will simply ignore theÂ `helmCharts:`Â section, and your PostgreSQL wonâ€™t be deployed.

TheÂ `--enable-helm`Â flag requires Kustomize version 4.1.0 or later. Check your version withÂ `kustomize version`.

**Soon, youâ€™ll learn how to enable this flag in Argo CD too!**

## Deploying with Argo CD: Single Environment

Now letâ€™s move to Argo CD. Weâ€™ll start by deploying just the development environment.

## What is an Argo CD Application?

An Argo CDÂ **Application**Â is a custom resource that tells Argo CD:

- **Where**Â to find your manifests (Git repo and path)
- **What**Â cluster and namespace to deploy to
- **How**Â to sync (automatic or manual)
- **When**Â to sync (on Git changes, or manually)

Itâ€™s essentially a deployment configuration that Argo CD watches and keeps in sync with your desired state in Git.

## The Dev Application Manifest

Hereâ€™s our Argo CD Application for the dev environment:

argocd/postgresql-dev-application.yaml

apiVersion: argoproj.io/v1alpha1  
kind: Application  
metadata:  
  name: postgresql-dev    
  namespace: argocd  
  finalizers:  
    - resources-finalizer.argocd.argoproj.io    
spec:  
  project: default

  source:  
    repoURL: git@github.com:nsalexamy/service-foundry-argocd.git    
    targetRevision: main    
    path: demo-apps/postgresql-gitops/dev  destination:  
    server: [https://kubernetes.default.svc](https://kubernetes.default.svc/)    
    namespace: dev    syncPolicy:  
    automated:    
      prune: true    
      selfHeal: true    
      allowEmpty: false    syncOptions:  
      - CreateNamespace=true    retry:    
      limit: 5  
      backoff:  
        duration: 5s  
        factor: 2  
        maxDuration: 3m

1. Name of the Argo CD Application
2. Ensures resources are cleaned up when the Application is deleted
3. Your Git repository URL (update this to your repo!)
4. Git branch or tag to track
5. Path to the dev Kustomize overlay
6. Kubernetes cluster to deploy to (default is the cluster where Argo CD runs)
7. Target namespace
8. Automatically sync when Git changes
9. Remove resources deleted from Git
10. Revert manual changes back to Git state
11. Create the namespace if it doesnâ€™t exist
12. Retry configuration for transient failures

## Deploying the Application

Letâ€™s deploy it:

# Apply the Application manifest  
kubectl apply -f argocd/postgresql-dev-application.yaml

# Check the status  
kubectl get application -n argocd postgresql-dev# Or use the Argo CD CLI  
argocd app get postgresql-dev

If everything is configured correctly, you should see your application in the Argo CD UI:

Figure 1. Argo CD UI â€” postgresql-dev Application

## Benefits of This Approach

Letâ€™s recap what weâ€™ve gained:

- âœ…Â **Clear separation**: Dev configuration lives inÂ `dev/`Â directory
- âœ…Â **Easy reviews**: Git diffs show exactly what changed
- âœ…Â **Helm compatibility**: Leverages the full Helm chart ecosystem
- âœ…Â **Scalable**: Easy to add staging and prod environments next

## Troubleshooting: TheÂ `--enable-helm`Â Error

You might encounter an error when Argo CD tries to sync your application:

Figure 2. Argo CD Comparison Error

Error Message

Failed to load target state: failed to generate manifest for source 1 of 1:  
rpc error: code = Unknown desc = kustomize build <path>/demo-apps/postgresql-gitops/dev  
failed exit status 1: Error: trouble configuring builtin HelmChartInflationGenerator  
with config: name: postgresql namespace: dev releaseName: postgresql  
repo: https://charts.bitnami.com/bitnami valuesFile: values-dev.yaml  
version: 16.7.27: must specify --enable-helm

**Donâ€™t panic!**Â This is expected and easy to fix.

## Why Does This Happen?

Remember theÂ `--enable-helm`Â flag we used with theÂ `kustomize`Â CLI? Argo CD uses Kustomize internally to build your manifests, but by default, it doesnâ€™t enable Helm support.

We need to tell Argo CD:Â _â€œHey, please use_Â `--enable-helm`Â _when building Kustomize applications."_

## The Fix: Configure Argo CD Globally

Unfortunately, Argo CD doesnâ€™t provide a way to enableÂ `--enable-helm`Â per-application. You must configure itÂ **globally**Â for all Kustomize applications by updating theÂ `argocd-cm`Â ConfigMap.

**Hereâ€™s how:**

# Patch the argocd-cm ConfigMap to add --enable-helm  
kubectl patch configmap argocd-cm -n argocd --type merge \  
  -p '{"data":{"kustomize.buildOptions":"--enable-helm"}}'

# Restart the repo server to pick up the change  
kubectl rollout restart deployment argocd-repo-server -n argocd# Wait for it to be ready  
kubectl rollout status deployment argocd-repo-server -n argocd --timeout=60s# Verify the configuration  
kubectl get configmap argocd-cm -n argocd \  
  -o jsonpath='{.data.kustomize\.buildOptions}'  
# Output: --enable-helm

## Refresh Your Application

Now trigger a refresh of your application:

# Hard refresh the application  
kubectl patch application postgresql-dev -n argocd --type merge \  
  -p '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"hard"}}}'

# Or delete and recreate it  
kubectl delete -f argocd/postgresql-dev-application.yaml  
kubectl apply -f argocd/postgresql-dev-application.yaml

Your application should now sync successfully!

## Setting This During Argo CD Installation

If youâ€™re installing Argo CD fresh (or can reinstall), you can configure this from the start by creating a custom values file:

argocd-custom-values.yaml

configs:  
  # Argo CD ConfigMap settings  
  cm:  
    # Enable Helm chart inflation for Kustomize apps  
    kustomize.buildOptions: --enable-helm

Then install Argo CD with:

helm install argocd argo/argo-cd \  
  --namespace argocd --create-namespace \  
  --values argocd-custom-values.yaml

**Reference:**Â For all availableÂ `argocd-cm`Â options, see the [official documentation]([https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/argocd-cm.yaml](https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/argocd-cm.yaml)).

## Scaling Up: Managing Multiple Environments

So far, weâ€™ve deployed just the dev environment. But what about staging and production?

You could create individual Application manifests for each environment:

- `postgresql-dev-application.yaml`
- `postgresql-staging-application.yaml`
- `postgresql-prod-application.yaml`

But this creates duplication and becomes tedious to manage. Thereâ€™s a better way:Â **ApplicationSet**.

## What is ApplicationSet?

Argo CDâ€™sÂ **ApplicationSet**Â is like a template engine for Applications. It automatically creates multiple Application resources from a single, reusable template using generators.

Think of it as:

Generator (list of environments) + Template = Multiple Applications

In our case: *Â **Generator**: A list of environments (dev, staging, prod) *Â **Template**: A reusable Application configuration *Â **Result**: Three Argo CD Applications, one per environment

## How ApplicationSet Works

ApplicationSet usesÂ **generators**Â to produce data, then applies that data to aÂ **template**. Common generators include:

- **List**: Hardcoded list of values (what weâ€™ll use)
- **Git**: Discover directories or files in a repo
- **Cluster**: Discover registered Kubernetes clusters

For each item produced by the generator, ApplicationSet creates an Application by filling in template variables.

## Our ApplicationSet Configuration

Letâ€™s look at ourÂ `postgresql-applicationset.yaml`:

argocd/postgresql-applicationset.yaml

apiVersion: argoproj.io/v1alpha1  
kind: ApplicationSet  
metadata:  
  name: postgresql-environments    
  namespace: argocd  
spec:  
  generators:    
  - list:  
      elements:  
      - env: dev    
        namespace: dev  
      - env: staging  
        namespace: staging  
      - env: prod  
        namespace: prod

  template:    
    metadata:  
      name: 'postgresql-{{env}}'    
      finalizers:  
        - resources-finalizer.argocd.argoproj.io  
    spec:  
      project: default      source:  
        repoURL: git@github.com:nsalexamy/service-foundry-argocd.git  
        targetRevision: main  
        path: 'demo-apps/postgresql-gitops/{{env}}'      destination:  
        server: [https://kubernetes.default.svc](https://kubernetes.default.svc/)  
        namespace: '{{namespace}}'        syncPolicy:  
        automated:  
          prune: true  
          selfHeal: true  
          allowEmpty: false        syncOptions:  
          - CreateNamespace=true        retry:  
          limit: 5  
          backoff:  
            duration: 5s  
            factor: 2  
            maxDuration: 3m

1. Name of the ApplicationSet resource
2. List generator that produces environment data
3. Each element represents one environment
4. Application template that will be applied to each environment
5. Variable substitution:Â `{browser}`Â will be replaced withÂ `dev`,Â `staging`, orÂ `prod`
6. Path points to the environment-specific directory
7. Namespace is also parameterized per environment

**What gets created:**

This single ApplicationSet will create three Applications:

1. `demo-postgresql-dev`Â â†’ deploys fromÂ `demo-apps/postgresql-gitops/dev`Â â†’ namespaceÂ `dev`
2. `demo-postgresql-staging`Â â†’ deploys fromÂ `demo-apps/postgresql-gitops/staging`Â â†’ namespaceÂ `staging`
3. `demo-postgresql-prod`Â â†’ deploys fromÂ `demo-apps/postgresql-gitops/prod`Â â†’ namespaceÂ `prod`

## Deploying the ApplicationSet

# Deploy the ApplicationSet  
kubectl apply -f argocd/postgresql-applicationset.yaml

# Check what Applications were created  
kubectl get applications -n argocd# You should see:  
# demo-postgresql-dev  
# demo-postgresql-staging  
# demo-postgresql-prod

View it in the Argo CD UI:

Press enter or click to view image in full size

![](https://miro.medium.com/v2/resize:fit:1050/1*COcXa9RlIOwiBGXMvuPQyg.png)

Figure 3. Argo CD UI â€” All PostgreSQL Environments

## Why Use ApplicationSet?

The benefits are clear:

- âœ…Â **DRY principle**: One template instead of multiple duplicate manifests
- âœ…Â **Consistency**: All environments use the same configuration pattern
- âœ…Â **Easy to scale**: Adding a new environment? Just add one line to theÂ `elements`Â list
- âœ…Â **GitOps-friendly**: The environment list is tracked in Git
- âœ…Â **Cleaner repo**: Fewer files to maintain

**When to use ApplicationSet vs individual Applications:**

**Use individual Applications**Â when:

- You only have 1â€“2 environments
- Environments differ significantly in structure
- Youâ€™re just getting started

**Use ApplicationSet**Â when:

- You have 3+ environments
- Environments follow the same pattern
- You want to scale easily

## Securing Secrets with SealedSecrets

So far, weâ€™ve been referencingÂ `postgresql-credentials-secret.yaml`Â files but havenâ€™t explained what they are. Letâ€™s fix that!

## The Problem: Secrets in GitOps

GitOps means everything in Git. But Kubernetes Secrets are only base64-encoded â€” anyone with access to your repo can decode them:

# Your "secret" is not really secret  
echo "cGFzc3dvcmQ=" | base64 -d  
# Output: password

This is aÂ **huge security risk**. How do we store secrets in Git safely?

## The Solution: SealedSecrets

**SealedSecrets**Â by Bitnami solves this problem using public-key cryptography:

1. You encrypt your secret using aÂ **public key**Â (safe to commit to Git)
2. Only the SealedSecrets controller in your cluster has theÂ **private key**Â to decrypt it
3. You commit the encryptedÂ `SealedSecret`Â to your Git repo (safe!)
4. Argo CD deploys theÂ `SealedSecret`Â to the cluster
5. The controller decrypts it and creates the actualÂ `Secret`

**Benefits:**

- âœ…Â **Secure**: Secrets are encrypted, not just encoded
- âœ…Â **GitOps-compatible**: Safe to commit encrypted secrets to Git
- âœ…Â **Per-environment**: Different secrets for dev, staging, prod
- âœ…Â **Declarative**: Managed as code through CI/CD

## How to Create Sealed Secrets

Iâ€™ve created a helper script to make this easy:

# Set your passwords and environment  
POSTGRES_PASSWORD="my-super-secret-password" \  
DBUSER_PASSWORD="another-secret" \  
REPLICATION_PASSWORD="replication-secret" \  
NAMESPACE=dev \  
./seal-postgresql-secret.sh

# Output:  
# Sealed secret created at postgresql-credentials-dev-sealed.yaml

This creates an encrypted secret file that you can safely commit to Git!

## The Script Explained

seal-postgresql-secret.sh

#!/bin/bash  
# Set defaults  
POSTGRES_PASSWORD=${POSTGRES_PASSWORD:-postgres}  
DBUSER_PASSWORD=${DBUSER_PASSWORD:-postgres}  
REPLICATION_PASSWORD=${REPLICATION_PASSWORD:-replication}  
NAMESPACE=${NAMESPACE:-dev}

SECRET_YAML_FILE="postgresql-credentials-${NAMESPACE}.yaml"  
SEALED_SECRET_YAML_FILE="postgresql-credentials-${NAMESPACE}-sealed.yaml"  
K8S_PUBLIC_CERT_FILE="pub-cert.pem"# Step 1: Create a regular Kubernetes Secret (dry-run only)  
kubectl create secret generic postgresql-credentials \  
    --from-literal=postgres-password=$POSTGRES_PASSWORD \  
    --from-literal=password=$DBUSER_PASSWORD \  
    --from-literal=replication-password=$REPLICATION_PASSWORD \  
    --namespace=$NAMESPACE \  
    --dry-run=client -o yaml > $SECRET_YAML_FILE# Step 2: Fetch the public key from your cluster  
kubeseal --fetch-cert \  
    --controller-name=sealed-secrets-controller \  
    --controller-namespace=kube-system \  
    > $K8S_PUBLIC_CERT_FILE# Step 3: Encrypt the secret using the public key  
kubeseal --cert $K8S_PUBLIC_CERT_FILE \  
    --format yaml < $SECRET_YAML_FILE > $SEALED_SECRET_YAML_FILE# Clean up temporary files  
rm $SECRET_YAML_FILE  
rm $K8S_PUBLIC_CERT_FILEecho "Sealed secret created at $SEALED_SECRET_YAML_FILE"

**What happens:**

1. Creates a standard Kubernetes Secret manifest (not applied to cluster)
2. Fetches the public encryption key from your SealedSecrets controller
3. Encrypts the secret using that public key
4. Outputs aÂ `SealedSecret`Â YAML file
5. Cleans up temporary files

The resultingÂ `SealedSecret`Â can only be decrypted by the controller in your cluster. Even if someone gets access to your Git repo, they canâ€™t decrypt it!

## Using Sealed Secrets

Once youâ€™ve created your sealed secret:

# Commit the sealed secret to Git  
git add dev/postgresql-credentials-secret.yaml  
git commit -m "Add encrypted dev credentials"  
git push

# Argo CD will deploy it automatically!

The SealedSecrets controller in your cluster will: 1. Detect the newÂ `SealedSecret`Â 2. Decrypt it using its private key 3. Create the actualÂ `Secret`Â namedÂ `postgresql-credentials`Â 4. PostgreSQL can now use this secret for authentication

Perfect! Secure secrets in a GitOps workflow.

## Putting It All Together

Letâ€™s review what weâ€™ve built:

**1. Directory Structure**

postgresql-gitops/  
â”œâ”€â”€ argocd/                    # Argo CD configurations  
â”œâ”€â”€ dev/                       # Dev environment config  
â”œâ”€â”€ staging/                   # Staging environment config  
â””â”€â”€ prod/                      # Prod environment config

**2. Per-Environment Files**

Each environment has:

- `kustomization.yaml`Â - Tells Kustomize what to build
- `values-*.yaml`Â - Environment-specific Helm values
- `*-secret.yaml`Â - Encrypted secrets

**3. Argo CD Configuration**

Two approaches:

- IndividualÂ `Application`Â per environment
- SingleÂ `ApplicationSet`Â for all environments (recommended)

**4. How It Works**

Git Push  
    â†“  
Argo CD Detects Change  
    â†“  
Kustomize Build (with --enable-helm)  
    â†“  
Download Helm Chart  
    â†“  
Render with Environment Values  
    â†“  
Deploy to Cluster  
    â†“  
SealedSecrets Controller Decrypts Secrets  
    â†“  
PostgreSQL Starts

## Conclusion

Congratulations! Youâ€™ve learned how to combine Kustomize and Helm to manage multi-environment deployments with Argo CD.

**Key takeaways:**

- âœ…Â **Kustomize + Helm**Â gives you the best of both worlds: structure and flexibility
- âœ…Â **One values file per environment**Â may involve duplication, but itâ€™s clearer
- âœ…Â **Enable**Â `--enable-helm`Â in Argo CDâ€™s ConfigMap for Helm chart inflation
- âœ…Â **ApplicationSet**Â makes managing multiple environments a breeze
- âœ…Â **SealedSecrets**Â lets you safely store encrypted secrets in Git

**Next steps:**

- Try this pattern with your own Helm charts
- Explore Argo CDâ€™s ApplicationSet generators (Git, Cluster)
- Set up promotion workflows (dev â†’ staging â†’ prod)
- Add automated tests before deployment

I hope this guide has been helpful! If you have questions or feedback, feel free to reach out.

Happy deploying! ğŸš€

[

Kubernetes

](https://medium.com/tag/kubernetes?source=post_page-----0c87132d296c---------------------------------------)

[

DevOps

](https://medium.com/tag/devops?source=post_page-----0c87132d296c---------------------------------------)

[

Cloud Native

](https://medium.com/tag/cloud-native?source=post_page-----0c87132d296c---------------------------------------)

[  
](https://medium.com/tag/gitops?source=post_page-----0c87132d296c---------------------------------------)